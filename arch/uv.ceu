#ifndef _UV_CEU
#define _UV_CEU

// TODO: int, u32 => ssize_t, size_t

#include "c.ceu"

native @plain
        _sockaddr,
        _sockaddr_in,
        _sockaddr_storage,
        _uv_buf_t,
        _uv_connect_t,
        _uv_fs_t,
        _uv_handle_t,
        _uv_stat_t,
        _uv_stream_t,
        _uv_tcp_t,
        _uv_write_t;

native @pure
        _GET_HOST_U32(),
        _uv_is_readable(),
        _uv_is_writable(),
        _uv_strerror();

native @nohold
        _ceu_uv_close(),
        _ceu_uv_fs_close(),
        _ceu_uv_fs_close_(),
        _ceu_uv_listen(),       // TODO: unlisten?
        _ceu_uv_tcp_connect(),  // TODO: diconnect?
        _ceu_uv_tcp_getpeerport(),
        _ceu_uv_tcp_getsockport(),
        _ceu_uv_write(),        // TODO: write_stop?
        _uv_accept(),
        _uv_buf_init(),
        _uv_close(),
        _uv_fs_req_cleanup(),
        _uv_inet_ntop(),
        _uv_ip4_addr(),
        _uv_read_stop(),
        _uv_tcp_bind(),         // TODO: unbind?
        _uv_tcp_getpeername(),
        _uv_tcp_getsockname();

native/pre do
    ##define UV_STREAM_ALIAS(x) ((uv_stream_t*)&x)
end

native do
    int ceu_uv_tcp_getpeerport (uv_tcp_t* tcp) {
        sockaddr_in name;
        int namelen = sizeof(name);
        uv_tcp_getpeername(tcp, (sockaddr*)&name, &namelen);
        char addr[16];
        uv_inet_ntop(AF_INET, &name.sin_addr, addr, sizeof(addr));
        int port = ntohs(name.sin_port);
        //_printf("%s:%d\n", (_char&&)&&addr, port);
        return port;
    }
    int ceu_uv_tcp_getsockport (uv_tcp_t* tcp) {
        sockaddr_in name;
        int namelen = sizeof(name);
        uv_tcp_getsockname(tcp, (sockaddr*)&name, &namelen);
        char addr[16];
        uv_inet_ntop(AF_INET, &name.sin_addr, addr, sizeof(addr));
        int port = ntohs(name.sin_port);
        //_printf("%s:%d\n", (_char&&)&&addr, port);
        return port;
    }
end

#define GET_HOST_U32(bytes,off) _ntohl(*((u32&&)&&(((_byte&&)&&bytes)[off])))

#define PUT_NETWORK_U32(bytes,off,host)             \
    do                                              \
        var u32 network = _htonl(host);             \
        _ceu_vector_copy_buffer(&&(bytes), off,     \
                                (byte&&)&&network,  \
                                sizeof(u32),1);     \
    end

input _uv_fs_t&& FS;
input (_uv_stream_t&&,_ssize_t, _uv_buf_t&&) UV_READ;
input (_uv_write_t&&,int)   UV_WRITE;
input (_uv_stream_t&&,int)  UV_LISTEN;
input (_uv_connect_t&&,int) UV_CONNECT;
input (_uv_stream_t&&,int)  UV_ERROR;

class UV_FS_open with
output:
    var int& fd;
    event void ok;
    function (char[]& path, int flags, int mode)=>UV_FS_open build;

input:
    var char[]& path;
    var int flags, mode;
do
    function (char[]& path, int flags, int mode)=>UV_FS_open build do
        this.path  = &path;
        this.flags = flags;
        this.mode  = mode;
    end

    var int fd_ = -1;
    this.fd = &fd_;

    var _uv_fs_t req_open  = _uv_fs_t();
    var _uv_fs_t req_close = _uv_fs_t();

    var int ret = _ceu_uv_fs_open(&&req_open, _UNSAFE_POINTER_TO_ALIAS((_char&&)&&path), flags, mode)
                    finalize with
                        _ceu_uv_fs_close_(&&req_close, req_open.result);
                        _uv_fs_req_cleanup(&&req_open);
                    end;
    if this.ret < 0 then
        async do end
    else
        var _uv_fs_t&& req = await FS until req==&&req_open;
        this.fd = req_open.result;
    end

    emit this.ok;
    await FOREVER;
end

class UV_FS_read with
    var UV_FS_open& open;
    var byte[]& buf;
    var int size, offset;
    function (UV_FS_open& open, byte[]& buf, int size, int offset)=>UV_FS_read run;
do
    function (UV_FS_open& open, byte[]& buf, int size, int offset)=>UV_FS_read run do
        this.open   = &open;
        this.buf    = &buf;
        this.size   = size;
        this.offset = offset;
    end

    var _uv_buf_t buf_ = _uv_buf_init((_char&&)(_byte&&)&&this.buf, this.size);
    var _uv_fs_t req_read = _uv_fs_t();

    var int ret = _ceu_uv_fs_read(&&req_read, this.open.fd, &&buf_, 1, this.offset)
                    finalize with
                        _uv_fs_req_cleanup(&&req_read);
                    end;
    if ret < 0 then
        escape ret;
    end
    var _uv_fs_t&& req = await FS until req==&&req_read;
    $this.buf := req_read.result;   // TODO?? try to remove this line
    escape req_read.result;
end

class UV_FS_write with
    var UV_FS_open& open;
    var byte[]& buf;
    var int size, offset;
    function (UV_FS_open& open, byte[]& buf, int size, int offset)=>UV_FS_write run;
do
    function (UV_FS_open& open, byte[]& buf, int size, int offset)=>UV_FS_write run do
        this.open   = &open;
        this.buf    = &buf;
        this.size   = size;
        this.offset = offset;
    end

    var _uv_buf_t buf_ = _uv_buf_init((_byte&&)&&this.buf, this.size);
    var _uv_fs_t req_write = _uv_fs_t();
    finalize with
        _uv_fs_req_cleanup(&&req_write);
    end

    var int ret = _ceu_uv_fs_write(&&req_write, this.open.fd, &&buf_, 1, this.offset)
                    finalize with
                        _uv_fs_req_cleanup(&&req_write);
                    end;
    if ret < 0 then
        escape ret;
    end
    var _uv_fs_t&& req = await FS until req==&&req_write;
    escape req_write.result;
end

class UV_FS_fstat with
    var UV_FS_open& open;
    var _uv_stat_t& stat;
    function (UV_FS_open& open, _uv_stat_t& stat)=>UV_FS_fstat run;
do
    function (UV_FS_open& open, _uv_stat_t& stat)=>UV_FS_fstat run do
        this.open = &open;
        this.stat = &stat;
    end

    var _uv_fs_t req_fstat = _uv_fs_t();
    finalize with
        _uv_fs_req_cleanup(&&req_fstat);
    end

    var int ret = _ceu_uv_fs_fstat(&&req_fstat, this.open.fd)
                    finalize with
                        _uv_fs_req_cleanup(&&req_fstat);
                    end;
    if ret < 0 then
        escape ret;
    end
    var _uv_fs_t&& req = await FS until req==&&req_fstat;

    this.stat = *((_uv_stat_t&&)req_fstat.ptr);

    escape 0;
end

// TODO: rename UV_Stream_Reader/Writer? build->run?
// TODO: function to signal "consumption", if the org is finalized w/ pending
//       consumption, then error

class UV_Stream_Read with
    var _uv_stream_t& stream;
    var byte[]&       bytes;
    var u32           next = 0;
    function (_uv_stream_t& stream, byte[]& bytes)=>UV_Stream_Read build;
    event int ok;
do
    function (_uv_stream_t& stream, byte[]& bytes)=>UV_Stream_Read build do
        this.stream = &stream;
        this.bytes  = &bytes;
    end

    $bytes = 0;

    this.stream.data = &&this.bytes;
    _assert(_uv_is_readable(&&this.stream));
    var int err = _ceu_uv_read_start(&&this.stream)
                    finalize with
                        _uv_read_stop(&&this.stream);
                    end;
    //_fprintf(_stderr, "uv-error: %s\n", _uv_strerror(err));
    _assert(err == 0);

    par/or do
        var _uv_stream_t&& s;
        var int err_;
        (s,err_) = await UV_ERROR until (s==&&this.stream);
        err = err_;
        emit this.ok => err;
    with
        loop do
            var _uv_buf_t&& buf_r;
            var _uv_stream_t&& s;
            var u32 n;
            (s,n,buf_r) = await UV_READ
                          until s == &&this.stream;// and
                                //((_byte&&)buf_r:base == ((_byte&&)&&this.bytes));

            _assert(n != 0); // TODO: if this happens, try to understand why
            _assert(n >= 0); // UV_ERROR aborts me

            next = next + n;
            emit this.ok => n;
        end
    end
    escape err;
end

class UV_Stream_ReadUntil with
    var UV_Stream_Read& reader;
    var u32             limit;
    function (UV_Stream_Read& reader, u32 limit)=>UV_Stream_ReadUntil run;
do
    function (UV_Stream_Read& reader, u32 limit)=>UV_Stream_ReadUntil run do
        this.reader = &reader;
        this.limit  = limit;
    end

    if reader.next >= this.limit then
        escape 0;
    end

    watching this.reader do
        loop do
            var int dt = await this.reader.ok;
            if dt < 0 then
                // TODO: versions w/ assert/escape
                _printf("error[%d]: %s\n", dt, _uv_strerror(dt));
                _assert(0);
                escape dt;
            end
            if this.reader.next >= this.limit then
                escape 0;
            end
        end
    end

    escape -1;
end

class UV_Stream_ReadLine with
    var _uv_stream_t& stream;
    var char[]&       string;
    function (_uv_stream_t& stream, char[]& string)=>UV_Stream_ReadLine build;
do
    function (_uv_stream_t& stream, char[]& string)=>UV_Stream_ReadLine build do
        this.stream = &stream;
        this.string = &string;
    end

    var UV_Stream_Read r = UV_Stream_Read.build(&this.stream,&this.string);

    watching r do
        loop do
            await r.ok;
            var char n=0, c=0;
            var int ret = _sscanf((_char&&)&&this.string, "%*[^\n]%[\n]%c", &&n,&&c);
            _assert(ret < 2);
            if ret == 1 then
                _assert(n == '\n');
                escape 0;
            end
        end
    end

    // client code must enclose with UV_ERROR
    _assert(0);
    escape -1;
end

class UV_Stream_Write with
input:
    var _uv_stream_t& stream;
    var byte[]&       bytes;
    var u32           starting, excluding;
    function (_uv_stream_t& stream, byte[]& bytes)=>UV_Stream_Write build;
    function (_uv_stream_t& stream, byte[]& bytes, u32 starting, u32 excluding)=>UV_Stream_Write build2;
do
    function (_uv_stream_t& stream, byte[]& bytes)=>UV_Stream_Write build do
        this.stream    = &stream;
        this.bytes     = &bytes;
        this.starting  = 0;
        this.excluding = $bytes;
    end
    function (_uv_stream_t& stream, byte[]& bytes, u32 starting, u32 excluding)=>UV_Stream_Write build2 do
        this.stream    = &stream;
        this.bytes     = &bytes;
        this.starting  = starting;
        this.excluding = excluding;
    end
    _assert($bytes >= this.excluding);
    _assert(this.starting <= this.excluding);

    // WRITE
    var _uv_write_t req_write = _uv_write_t();
    var _uv_buf_t buf = _uv_buf_init((_byte&&)&&this.bytes, $this.bytes);
                  buf.base = buf.base+starting;
                  buf.len  = excluding-starting;
    _assert(_uv_is_writable(&&this.stream));
    var int ret = _ceu_uv_write(&&req_write, (_uv_stream_t&&)&&this.stream, &&buf);
    _assert(ret >= 0);
    var _uv_write_t&& w;
    var int status;
    (w, status) = await UV_WRITE until w==&&req_write;

    // force external UV_ERROR
    _assert(status == 0);
end

class UV_TCP_Client with
    var char[]& ip;
    var int port;
    event int ok;
output:
    var _uv_tcp_t& tcp;

    function (char[]& ip, int port)=>UV_TCP_Client build;
do
    function (char[]& ip, int port)=>UV_TCP_Client build do
        this.ip   = &ip;
        this.port = port;
    end

    // CLIENT
    var _uv_tcp_t&? tcp_;
    finalize
        tcp_ = &_malloc(sizeof(_uv_tcp_t));
    with
        // free after uv_close
    end
    this.tcp = &tcp_!;
    _ceu_uv_tcp_init(&&tcp)
        finalize with
            _ceu_uv_close((_uv_handle_t&&)&&tcp);
        end;

    var _uv_connect_t&? connect_;
    finalize
        connect_ = &_malloc(sizeof(_uv_connect_t));
    with
        // free on uv callback
    end

    var _sockaddr_in dest = _sockaddr_in();
    _uv_ip4_addr((_char&&)&&this.ip, this.port, &&dest);
    _ceu_uv_tcp_connect(&&connect_!, &&tcp, (_sockaddr&&)&&dest);

    do
        var _uv_connect_t&& c;
        var int err;
        (c,err) = await UV_CONNECT until c==&&connect_!;
        emit this.ok => err;
    end

    do
        var _uv_stream_t&& s;
        var int err;
        (s,err) = await UV_ERROR until (s==(_uv_stream_t&&)&&this.tcp);
        escape err;
    end
end

#endif
