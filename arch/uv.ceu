native @plain
        _ceu_uv_read_t,
        _sockaddr,
        _sockaddr_in,
        _uv_buf_t,
        _uv_fs_t,
        _uv_stream_t,
        _uv_tcp_t,
        _uv_write_t;

native @pure
        _uv_strerror();

native @nohold
        _ceu_uv_fs_close(),
        _ceu_uv_listen(),       // TODO: unlisten?
        _ceu_uv_write(),        // TODO: write_stop?
        _uv_accept(),
        _uv_buf_init(),
        _uv_close(),
        _uv_fs_req_cleanup(),
        _uv_ip4_addr(),
        _uv_read_stop(),
        _uv_tcp_bind(),         // TODO: unbind?
        _uv_tcp_getsockname();

native/pre do
    typedef struct sockaddr         sockaddr;
    typedef struct sockaddr_in      sockaddr_in;
    typedef struct sockaddr_storage sockaddr_storage;
    typedef struct {
        uv_buf_t buf;
        int has_pending_data;
    } ceu_uv_read_t;
end

input _uv_fs_t&& FS;

class UV_FS_open with
output:
    event int ok;
    function (@hold char&& path, int flags, int mode)=>UV_FS_open build;

input:
    var char&& path;
    var int flags, mode;
do
    function (@hold char&& path, int flags, int mode)=>UV_FS_open build do
        this.path  := path;
        this.flags = flags;
        this.mode  = mode;
    end

    var _uv_fs_t req_open  = _uv_fs_t();
    var _uv_fs_t req_close = _uv_fs_t();

    var int ret = _ceu_uv_fs_open(&&req_open, path, flags, mode)
                    finalize with
                        _uv_fs_req_cleanup(&&req_open);
                        _ceu_uv_fs_close(&&req_close, req_open.result);
                    end;
    if ret < 0 then
        async do end
    else
        var _uv_fs_t&& req = await FS until req==&&req_open;
        ret = req_open.result;
    end

    emit this.ok => ret;
    await FOREVER;
end

class UV_FS_read with
input:
    var _char&& buf;
    var int h, size, offset;
    function (int h, @hold _char&& buf, int size, int offset)=>UV_FS_read build;
do
    function (int h, @hold _char&& buf, int size, int offset)=>UV_FS_read build do
        this.h      = h;
        this.buf   := buf;
        this.size   = size;
        this.offset = offset;
    end

    var _uv_buf_t buf_ = _uv_buf_init(this.buf, this.size);
    var _uv_fs_t req_read = _uv_fs_t();
    finalize with
        _uv_fs_req_cleanup(&&req_read);
    end

    var int ret = _ceu_uv_fs_read(&&req_read, this.h, &&buf_, 1, this.offset)
                    finalize with
                        _uv_fs_req_cleanup(&&req_read);
                    end;
    if ret < 0 then
        escape ret;
    end
    var _uv_fs_t&& req = await FS until req==&&req_read;
    escape req_read.result;
end
