#ifndef _UV_CEU
#define _UV_CEU

#include "c.ceu"

native @plain
        _ceu_uv_read_t,
        _sockaddr,
        _sockaddr_in,
        _uv_buf_t,
        _uv_connect_t,
        _uv_fs_t,
        _uv_stream_t,
        _uv_tcp_t,
        _uv_write_t;

native @pure
        _uv_strerror();

native @nohold
        _ceu_uv_fs_close(),
        _ceu_uv_listen(),       // TODO: unlisten?
        _ceu_uv_tcp_connect(),  // TODO: diconnect?
        _ceu_uv_write(),        // TODO: write_stop?
        _uv_accept(),
        _uv_buf_init(),
        _uv_close(),
        _uv_fs_req_cleanup(),
        _uv_ip4_addr(),
        _uv_read_stop(),
        _uv_tcp_bind(),         // TODO: unbind?
        _uv_tcp_getsockname();

native/pre do
    ##define UV_STREAM_ALIAS(x) ((uv_stream_t*)&x)
end

input _uv_fs_t&& FS;
input (_uv_stream_t&&,_ssize_t, _uv_buf_t&&) UV_READ;
input (_uv_write_t&&,int) UV_WRITE;
input (_uv_stream_t&&,int) UV_LISTEN;
input (_uv_connect_t&&,int) UV_CONNECT;
input (_uv_stream_t&&,int) UV_ERROR;

class UV_FS_open with
output:
    event int ok;
    function (@hold char&& path, int flags, int mode)=>UV_FS_open build;

input:
    var char&& path;
    var int flags, mode;
do
    function (@hold char&& path, int flags, int mode)=>UV_FS_open build do
        this.path  := path;
        this.flags = flags;
        this.mode  = mode;
    end

    var _uv_fs_t req_open  = _uv_fs_t();
    var _uv_fs_t req_close = _uv_fs_t();

    var int ret = _ceu_uv_fs_open(&&req_open, _UNSAFE_POINTER_TO_ALIAS(path), flags, mode)
                    finalize with
                        _uv_fs_req_cleanup(&&req_open);
                        _ceu_uv_fs_close(&&req_close, req_open.result);
                    end;
    if ret < 0 then
        async do end
    else
        var _uv_fs_t&& req = await FS until req==&&req_open;
        ret = req_open.result;
    end

    emit this.ok => ret;
    await FOREVER;
end

class UV_FS_read with
    var byte[]& buf;
    var int h, size, offset;
    function (int h, byte[]& buf, int size, int offset)=>UV_FS_read build;
do
    function (int h, byte[]& buf, int size, int offset)=>UV_FS_read build do
        this.h      = h;
        this.buf    = &buf;
        this.size   = size;
        this.offset = offset;
    end

    var _uv_buf_t buf_ = _uv_buf_init((_byte&&)&&this.buf, this.size);
    var _uv_fs_t req_read = _uv_fs_t();
    finalize with
        _uv_fs_req_cleanup(&&req_read);
    end

    var int ret = _ceu_uv_fs_read(&&req_read, this.h, &&buf_, 1, this.offset)
                    finalize with
                        _uv_fs_req_cleanup(&&req_read);
                    end;
    if ret < 0 then
        escape ret;
    end
    var _uv_fs_t&& req = await FS until req==&&req_read;
    $this.buf := req_read.result;
    escape req_read.result;
end

#define BUFFER_MAX 1024

class UV_Stream_Read with
    var _uv_stream_t& stream;
    var char[]&       string;
    function (_uv_stream_t& stream, char[]& string)=>UV_Stream_Read build;
    event int ok;
do
    function (_uv_stream_t& stream, char[]& string)=>UV_Stream_Read build do
        this.stream = &stream;
        this.string = &string;
    end

    var _byte[BUFFER_MAX] buf_ = [];
    var _ssize_t n_read = 0;

    var _uv_buf_t buf = _uv_buf_init(buf_, BUFFER_MAX);
    var _ceu_uv_read_t r = _ceu_uv_read_t(buf,0);
    this.stream.data = &&r;
    var int ret = _ceu_uv_read_start(&&this.stream)
                    finalize with
                        _assert(r.has_pending_data == 0);
                        _uv_read_stop(&&this.stream);
                    end;
    //_printf("error: %s\n", _uv_strerror(ret));
    _assert(ret == 0);

    loop do
        var _uv_buf_t&& buf_r;
        var _uv_stream_t&& s;
        (s,n_read,buf_r) = await UV_READ until s==&&this.stream;
        _assert(buf_r:base == buf.base);
        _assert(buf_r:len  == buf.len);
        //_assert(n_read >= 0);  // connection closed?
        if n_read < 0 then
            _fprintf(_stderr, "[UV_Stream_Read] error: %s\n", _uv_strerror(n_read));
            break;
        else/if n_read == 0 then
            //_assert(0);   // can happen with multiple writes over "buf_"
        end
        buf_[n_read] = '\0';
        this.string = [] .. this.string .. (char&&)buf_;
        emit this.ok => n_read;
    end
end

class UV_Stream_ReadLine with
    var _uv_stream_t& stream;
    var char[]&       string;
    function (_uv_stream_t& stream, char[]& string)=>UV_Stream_ReadLine build;
do
    function (_uv_stream_t& stream, char[]& string)=>UV_Stream_ReadLine build do
        this.stream = &stream;
        this.string = &string;
    end

    var UV_Stream_Read r = UV_Stream_Read.build(&this.stream,&this.string);
    loop do
        await r.ok;
        var char n=0, c=0;
        var int ret = _sscanf((_char&&)&&this.string, "%*[^\n]%[\n]%c", &&n,&&c);
        _assert(ret < 2);
        if ret == 1 then
            _assert(n == '\n');
            break;
        end
    end
end

class UV_Stream_Write with
    var _uv_stream_t& stream;
    var byte[]&       bytes;
    function (_uv_stream_t& stream, byte[]& bytes)=>UV_Stream_Write build;
do
    function (_uv_stream_t& stream, byte[]& bytes)=>UV_Stream_Write build do
        this.stream = &stream;
        this.bytes  = &bytes;
    end

    // WRITE
    var _uv_write_t req_write = _uv_write_t();
    var _uv_buf_t buf = _uv_buf_init((_byte&&)&&this.bytes, $this.bytes);
    var int ret = _ceu_uv_write(&&req_write, (_uv_stream_t&&)&&this.stream, &&buf);
    _assert(ret >= 0);
    var _uv_write_t&& w;
    var int status;
    (w, status) = await UV_WRITE until w==&&req_write;
    _assert(status == 0);
end

class UV_TCP_Client with
    var char[]& ip;
    var int port;
    event int ok;
output:
    var _uv_tcp_t& tcp;

    function (char[]& ip, int port)=>UV_TCP_Client build;
do
    function (char[]& ip, int port)=>UV_TCP_Client build do
        this.ip   = &ip;
        this.port = port;
    end

    // CLIENT
    var _uv_tcp_t&? tcp_;
    finalize
        tcp_ = &_malloc(sizeof(_uv_tcp_t));
    with
        // free after uv_close
    end
    this.tcp = &tcp_!;
    _ceu_uv_tcp_init(&&tcp)
        finalize with
            _uv_close((_uv_handle_t&&)&&tcp, _ceu_uv_free);
        end;

    var _uv_connect_t connect = _uv_connect_t();
    var _sockaddr_in dest = _sockaddr_in();
    _uv_ip4_addr((_char&&)&&this.ip, this.port, &&dest);
    _ceu_uv_tcp_connect(&&connect, &&tcp, (_sockaddr&&)&&dest);

    do
        var _uv_connect_t&& c;
        var int status;
        (c,status) = await UV_CONNECT until c==&&connect;
        emit this.ok => status;
    end

    do
        var _uv_stream_t&& s;
        var int status;
        (s,status) = await UV_ERROR until (s==(_uv_stream_t&&)&&this.tcp);
    end
end

class UV_TCP_Server_Connection with
    function (_uv_tcp_t& server)=>UV_TCP_Server_Connection build;
    var _uv_tcp_t& server;
do
    function (_uv_tcp_t& server)=>UV_TCP_Server_Connection build do
        this.server = &server;
    end

    // CLIENT
    var _uv_tcp_t&? client_;
    finalize
        client_ = &_malloc(sizeof(_uv_tcp_t));
    with
        // free after uv_close
    end
    var _uv_tcp_t& client = &client_!;
    _ceu_uv_tcp_init(&&client)
        finalize with
            _uv_close((_uv_handle_t&&)&&client, _ceu_uv_free);
        end;

    // ACCEPT
    var int ret = _uv_accept((_uv_stream_t&&)&&server,(_uv_stream_t&&)&&client);
    _assert(ret == 0);

#ifdef UV_TCP_SERVER_HANDLER_CEU
#define _UV_STRINGIFY(X) #X
#define UV_STRINGIFY(X) _UV_STRINGIFY(X)
#include UV_STRINGIFY(UV_TCP_SERVER_HANDLER_CEU)
    do UV_TCP_Server_Handler.build(&client);
#else
    _assert(0);
#endif
end

class UV_TCP_Server with
    var char[]& ip;
    var int port;
    var int backlog;
    function (char[]& ip, int port, int backlog)=>UV_TCP_Server build;
do
    function (char[]& ip, int port, int backlog)=>UV_TCP_Server build do
        this.ip      = &ip;
        this.port    = port;
        this.backlog = backlog;
    end

    var _uv_tcp_t&? server_;
    finalize
        server_ = &_malloc(sizeof(_uv_tcp_t));
    with
        // free after uv_close
    end
    var _uv_tcp_t& server = &server_!;
    _ceu_uv_tcp_init(&&server)
        finalize with
            _uv_close((_uv_handle_t&&)&&server, _ceu_uv_free);
        end;

    var _sockaddr_in addr = _sockaddr_in();
    _uv_ip4_addr((_char&&)&&this.ip, this.port, &&addr);
    _uv_tcp_bind(&&server, (_sockaddr&&)&&addr, 0);
    do
        var int ret = _ceu_uv_listen((_uv_stream_t&&)&&server, this.backlog);
        _assert(ret == 0);
    end

    every (s,status) in UV_LISTEN do
        if s == (_uv_stream_t&&)&&server then
            _assert(status >= 0);
            spawn UV_TCP_Server_Connection.build(&server);
        end
    end
end

#endif
