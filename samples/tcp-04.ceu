#if 0
#@ Description: Parallel "echo" servers.
#@  - same as `tcp-03.ceu`
#@ Features:
#@  - class Read & ReadLine & Write
#endif

#include "uv/tcp.ceu"

#define DEFAULT_PORT    7000
#define DEFAULT_BACKLOG 128
#define BUFFER_MAX      10

code/await Connect (var& _uv_tcp_t server) => void
do
    // CLIENT
    var& _uv_tcp_t_ptr? client_ = &_malloc(sizeof(_uv_tcp_t))
        finalize (client_) with
            // free after uv_close
        end;
    var& _uv_tcp_t_ptr client = &client_!;
    _ceu_uv_tcp_init(client);
    do finalize with
        _ceu_uv_close(client as _uv_handle_t&&);
    end

    // ACCEPT
    do
        var int ret = _uv_accept(&&server as _uv_stream_t&&,client as _uv_stream_t&&);
        _ceu_dbg_assert(ret == 0);
    end

    // READ/WRITE LOOP

    vector[BUFFER_MAX] byte buf;
    var ssize n_read = (0 as ssize);

    spawn do
        var _uv_stream_t&& s;
        var int            err;
        every (s,err) in UV_ERROR do
            _fprintf(_stderr, "[error]: %s\n", _uv_strerror(err));
        end
    end

    loop do
        //var char[] string;
        //do UV_Stream_ReadLine.build(&_UV_STREAM_ALIAS(client), &string);
        //_printf("[read] %s", (_char&&)&&string);
        //do UV_Stream_Write.build(&_UV_STREAM_ALIAS(client), &string);

        // READ
        do
            $buf = 0;
            client:_data = _PURIFY(&&buf);
            var int ret;
            do
                ret = _ceu_uv_read_start(client as _uv_stream_t&&);
            finalize (client) with
                // finalize after each UV_READ
                _uv_read_stop(client as _uv_stream_t&&);
            end
            //_printf("error: %s\n", _uv_strerror(ret));
            _ceu_dbg_assert(ret == 0);

            var _uv_buf_t&& buf_r;
            var _uv_stream_t&& s;
            (s,n_read,buf_r) = await UV_READ until s==(client as _uv_stream_t&&);
            //_ceu_dbg_assert((_byte&&)buf_r:base == ((_byte&&)&&buf));
            //_ceu_dbg_assert(buf_r:len == $$buf);
        end
        //_ceu_dbg_assert(n_read >= 0);  // connection closed?
        if n_read < 0 then
            _fprintf(_stderr, "[read]: %s\n", _uv_strerror(n_read));
            break;
        else/if (n_read as int) == 0 then
            _ceu_dbg_assert(0);
        end

        // not reading anymore

        // WRITE
        await UV_Stream_Write(&_UV_STREAM_ALIAS(client), &buf);
    end
end

code/await Server (var _char&& ip, var int port, var int backlog) => void
do
    var& _uv_tcp_t_ptr? server_ = &_malloc(sizeof(_uv_tcp_t))
        finalize (server_) with
            // free after uv_close
        end;
    var& _uv_tcp_t_ptr server = &server_!;
    _ceu_uv_tcp_init(server);
    do finalize with
        _uv_close(server as _uv_handle_t&&, _ceu_uv_free);
    end

    var _sockaddr_in addr = _;
    _uv_ip4_addr(&&ip[0], port, &&addr);
    _uv_tcp_bind(server, &&addr as _sockaddr&&, 0);
    do
        var int ret = _ceu_uv_listen(server as _uv_stream_t&&, backlog);
        _ceu_dbg_assert(ret == 0);
    end

    pool[10] Connect cs;

    var _uv_stream_t&& s;
    var int status;
    every (s,status) in UV_LISTEN do
        if s == (server as _uv_stream_t&&) then
            _ceu_dbg_assert(status >= 0);
            spawn Connect(&server) in cs;
        end
    end
end

spawn Server("0.0.0.0", DEFAULT_PORT+0, DEFAULT_BACKLOG);
spawn Server("0.0.0.0", DEFAULT_PORT+1, DEFAULT_BACKLOG);

_printf("I will terminate after 10s...\n");
await 10s;
_printf("DONE!\n");
escape 0;
