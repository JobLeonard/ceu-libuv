#if 0
#@ Description: Sequential "echo" server.
#@  - one port: 7000
#@  - one client at a time
#@  - one read / write at a time
#@  - dies if reads BUFFER_MAX at a time
#@ Usage:
#@  - connect a "netcat" client to port 7000
#@      - write anything
#@      - read the "echo"
#@  - connect another "netcat" client to port 7000
#@      - write anything
#@      - no "echo"
#@      - close first client
#@      - read the "echo"
#@  - write long string
#@      - ERROR!
#@ Features:
#@  - UV_LISTEN, UV_READ, UV_WRITE
#endif

#include "c.ceu"
#include "uv.ceu"

input (_uv_stream_t&&,int) UV_LISTEN;
input (_uv_stream_t&&,_ssize_t, _uv_buf_t&&) UV_READ;
input (_uv_write_t&&,int) UV_WRITE;

#define DEFAULT_PORT    7000
#define DEFAULT_BACKLOG 128
#define BUFFER_MAX      10

var _uv_tcp_t server = _uv_tcp_t();
_ceu_uv_tcp_init(&&server)
    finalize with
        _uv_close((_uv_handle_t&&)&&server, null);
    end;

var _sockaddr_in addr = _sockaddr_in();
_uv_ip4_addr("0.0.0.0", DEFAULT_PORT, &&addr);
_uv_tcp_bind(&&server, (_sockaddr&&)&&addr, 0);
do
    var int ret = _ceu_uv_listen((_uv_stream_t&&)&&server, DEFAULT_BACKLOG);
    _assert(ret == 0);
end

_printf("I will terminate after two connections...\n");

loop i in 2 do
    // ACCEPT
    var _uv_tcp_t&? client_;
    finalize
        client_ = &_malloc(sizeof(_uv_tcp_t));
    with
        // free after uv_close
    end
    var _uv_tcp_t& client = &client_!;
    _ceu_uv_tcp_init(&&client)
        finalize with
            _uv_close((_uv_handle_t&&)&&client, _ceu_uv_free);
        end;

    loop do
        var int ret = _uv_accept((_uv_stream_t&&)&&server,(_uv_stream_t&&)&&client);
        if ret == 0 then
            break;
        else
            // LISTEN
            var _uv_stream_t&& s;
            var int status;
            (s,status) = await UV_LISTEN until s==(_uv_stream_t&&)&&server;
            _assert(status >= 0);
        end
    end

    // READ/WRITE LOOP
    var _char[BUFFER_MAX] buf_ = [];
    var _ssize_t n_read = 0;
    loop do
        // READ
        do
            var _uv_buf_t buf = _uv_buf_init(buf_, BUFFER_MAX-1);
            var _ceu_uv_read_t r = _ceu_uv_read_t(buf,0);
            client.data = &&r;
            var int ret = _ceu_uv_read_start((_uv_stream_t&&)&&client)
                            finalize with end;
            finalize with
                // finalize after each UV_READ
                _assert(r.has_pending_data == 0);
                _uv_read_stop((_uv_stream_t&&)&&client);
            end;
            //_printf("error: %s\n", _uv_strerror(ret));
            _assert(ret == 0);

            var _uv_buf_t&& buf_r;
            var _uv_stream_t&& s;
            (s,n_read,buf_r) = await UV_READ until s==(_uv_stream_t&&)&&client;
            _assert(buf_r:base == buf.base);
            _assert(buf_r:len  == buf.len);
        end
        //_assert(n_read >= 0);  // connection closed?
        if n_read < 0 then
            _fprintf(_stderr, "error: %s\n", _uv_strerror(n_read));
            break;
        else/if n_read == 0 then
            _assert(0);
        end

        // not reading anymore

        // WRITE
        buf_[n_read] = '\0';
        var _uv_write_t req_write = _uv_write_t();
        var _uv_buf_t buf = _uv_buf_init(buf_, n_read);
        _ceu_uv_write(&&req_write, (_uv_stream_t&&)&&client, &&buf);
        var _uv_write_t&& w;
        var int status;
        (w, status) = await UV_WRITE until w==&&req_write;
        _assert(status == 0);
    end
end

_printf("DONE!\n");
escape 0;
