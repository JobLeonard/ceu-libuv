#if 0
#@ Description: Parallel "echo" server.
#@  - same as `tcp-01.ceu`
#@  - accepts multiple clients at the same time
#@ Usage:
#@  - connect "telnet" clients to port 7000
#@  - write long string
#@      - ERROR!
#@ Features:
#@  - class Connection
#@  - spawn Connection
#endif

#include "uv/tcp.ceu"

#define DEFAULT_PORT    7000
#define DEFAULT_BACKLOG 128
#define BUFFER_MAX      10

code/await Connect (var& _uv_tcp_t_ptr server) => void
do
    // CLIENT
    var& _uv_tcp_t_ptr client;
    var int? err =
        watching UV_TCP_Open() => (client) do
            var int ret = _uv_accept(server as _uv_stream_t_ptr, client as _uv_stream_t_ptr);
            _ceu_dbg_assert(ret == 0);

            // READ/WRITE LOOP

            vector[BUFFER_MAX] byte buf;
            var ssize n_read = 0;

            spawn do
                var _uv_stream_t&& s;
                var int            err;
                every (s,err) in UV_ERROR do
                    _fprintf(_stderr, "[error]: %s\n", _uv_strerror(err));
                end
            end

            loop do
                var ssize n_read = 0;

                do
                    event& ssize ok_read;
                    var int? err =
                        watching UV_Stream_Read(&(client as _uv_stream_t_ptr),&buf) => (ok_read) do
                            n_read = await ok_read;
                        end;
                    _ceu_dbg_assert(not err?);
                end

                // WRITE
                buf = buf..[{'\0'}];
                var& _uv_write_t_ptr? req_write = &_malloc(sizeof(_uv_write_t))
                    finalize (req_write) with
                        // free on uv callback
                    end;
                var _uv_buf_t buf_ = _uv_buf_init(&&buf[0], n_read);
                _ceu_uv_write(req_write!, client as _uv_stream_t_ptr, &&buf_);
                var _uv_write_t&& w;
                var int status;
                (w, status) = await UV_WRITE until w==req_write!;
                _ceu_dbg_assert(status == 0);
            end
        end;

    if err? then
        _fprintf(_stderr, "[connect]: %s\n", _uv_strerror(err!));
    end
end

_printf("I will terminate after 10s...\n");

var& _uv_tcp_t_ptr server;
watching UV_TCP_Open() => (server)
do
    var _sockaddr_in addr = _;
    _uv_ip4_addr("0.0.0.0", DEFAULT_PORT, &&addr);
    _uv_tcp_bind(server, &&addr as _sockaddr&&, 0);

    event& int ok_listen;
    watching UV_Stream_Listen(&(server as _uv_stream_t_ptr), DEFAULT_BACKLOG) => (ok_listen)
    do
        pool[10] Connect cs;
        watching 10s do
            var int status;
            every status in ok_listen do
                _ceu_dbg_assert(status >= 0);
                spawn Connect(&server) in cs;
            end
        end
    end
end

_printf("DONE!\n");
escape 0;
