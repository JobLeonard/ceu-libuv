#ifndef _UV_TCP_CEU
#define _UV_TCP_CEU

#include "uv/stream.ceu"

native/plain
    _uv_tcp_t,
;

native/nohold
    _uv_tcp_bind,         // TODO: unbind?
    _uv_tcp_getsockname,
;

native
    _ceu_uv_tcp_init,
    _uv_tcp_t_ptr,
;

native/pre do
    typedef uv_tcp_t* uv_tcp_t_ptr;
end

native/pos do
    ##define ceu_uv_tcp_init(a) uv_tcp_init(&ceu_uv_loop, a);
end

code/await UV_TCP_Open (void) => (var& _uv_tcp_t_ptr tcp) => int // err
do
    var& _uv_tcp_t_ptr? tcp_ = &_malloc(sizeof(_uv_tcp_t))
        finalize (tcp_) with
            // free after "uv_close" below
        end;
    if not tcp_? then
        escape _UV_EAI_MEMORY;
    end

    tcp = &tcp_!;

    var int err;
    do
        err = _ceu_uv_tcp_init(tcp_!);
    finalize (tcp_) with
        _ceu_uv_close(tcp_! as _uv_handle_t&&);
    end
    if err != 0 then
        escape err;
    end

    var _uv_stream_t_ptr s;
    var int err;
    (s,err) = await UV_ERROR until (s==(tcp_! as _uv_stream_t_ptr));
    escape err;
end

#endif
